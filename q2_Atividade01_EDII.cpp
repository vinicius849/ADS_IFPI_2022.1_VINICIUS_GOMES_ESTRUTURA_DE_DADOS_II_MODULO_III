#include <iostream>
using namespace std;
template <class T>
class ArvoreNo {
};
          /* Raiz Esquerda Direita é o tipo de percurso que envolve manipulação de ponteiros,
          sendo essa ordem os 3 métodos de percurso de uma árvore binária. */
          
	int *esq, *dir;
	
	public:
	No(int chave) {
    void imprime(No *n) {
    	if (raiz == NULL) {
    		cout << "\n <Vazio>";
		}else{
			if (n != NULL) {
				cout << "<" << n -> valor;
				imprime(n -> esq);
				imprime(n -> dir);
				cout << ">";
			}
		}else{
			cout << "<>";
		}
	}
	
	     /* Esquerda Raiz Direita é um tipo mais convencional pois estabelece a raiz no centro(nó), 
	     o ponteiro definido para apontar à esquerda e o ponteiro definido para apontar à direita. A função 
		 de chamada de função com recursividade. */
		 
	typedef struct;
	    No, n;
	}ArvB;
	
	void imprime(No *n) {
		if (No == NULL) {
			cout << "\n <Vazio>";
		}else {
			cout << "\n <Método padrão de árvore binária não vazia>";
		}
	}
	while(n != 0) {
		anterior = raiz;
		if (valor < raiz -> valor) {
			raiz = raiz -> esquerda;
		}else {
			raiz = raiz -> direita;
		}
	}
	
	  [250, 500, 750]   // Exemplo forte de árvore binária ordenada, isto é, esquerda, raiz, direita tomando o número 500 como raiz(Nó) da análise.
	  
	     
		 
		 /* Esquerda Direita Raiz é o tipo de árvore binária não ordenada pela árvore binária trtadicional. Ou seja,
		 não equilibrada no critério de busca e ordenação de resultados PÓS-ORDEM! Porque percorre o lado esquerdo, 
		 percorre o lado direito e trata a raiz por último. Exemplo: d b e f c a. */
		 
	typedef struct;
	    No, n;
	}ArvB;
	
	int *esq, *dir;         //Método de descobrir as "raízes" do problema: conferir se ela é vazia e comparar o percurso PÓS ORDEM da questão.
	void imprime(No *n) {
		if (No == NULL) {
			cout << "\n <Vazio>";
		}else {
			cout << "\n <Método padrão de árvore binária não vazia>";
		}
	}
	void posOrdem_ArBin(ArvBin *raiz) {
		if ( raiz == NULL) {
		return;
		}
		if(*raiz != NULL) {
			posOrdem_ArvBin(&((*raiz) -> esq));
			pos_Ordem_Arv_Bin(&(*raiz) -> dir));
			cout << "\n %d\n", (*raiz -> valor);
		}
	}
	
	 [750, 250, 500] // Exemplo forte e bem requisitado pela questão, no caso tomando o número 500 como raiz(Nó) da análise.
	   
	   
	     
	
		
